/**
 * Auto-title helpers for wardrobe items.
 *
 * Goals:
 * - Prevent infinite "Untitled" items.
 * - Generated titles are locale-driven (i18n).
 * - User-provided titles are preserved exactly as entered.
 * - Generated titles are marked in metadata (autoTitle) to distinguish them.
 */

import { CATEGORY_LABELS, CATEGORY_LABELS_EN } from '@/constants/categories';
import { ItemCategory, WardrobeItem } from '@/types/models/item';
import i18n from '@lib/i18n/config';

export type AutoTitleMetadata = {
  kind: 'categoryCounter';
  category: ItemCategory;
  number: number;
};

function escapeRegex(str: string): string {
  return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function uniqStrings(values: Array<string | undefined | null>): string[] {
  const out: string[] = [];
  const seen = new Set<string>();
  for (const v of values) {
    if (!v) continue;
    const s = String(v);
    if (!s.trim()) continue;
    if (seen.has(s)) continue;
    seen.add(s);
    out.push(s);
  }
  return out;
}

function getCategoryLabelCandidates(category: ItemCategory): string[] {
  const tRu = i18n.getFixedT('ru', 'categories');
  const tEn = i18n.getFixedT('en', 'categories');

  return uniqStrings([
    // Locales (preferred source of truth)
    tRu(`items.${category}`),
    tEn(`items.${category}`),

    // Legacy constants (backward compatibility)
    CATEGORY_LABELS[category],
    CATEGORY_LABELS_EN[category],
  ]);
}

function extractNumberFromTitle(
  title: string | undefined,
  labelCandidates: string[],
): number | null {
  if (!title) return null;

  for (const label of labelCandidates) {
    const regex = new RegExp(`^${escapeRegex(label)}\\s+(\\d+)$`, 'i');
    const match = title.match(regex);
    if (match && match[1]) {
      const parsed = parseInt(match[1], 10);
      if (!Number.isNaN(parsed)) return parsed;
    }
  }

  return null;
}

export function getLocalizedCategoryLabel(category: ItemCategory): string {
  // Use i18n in the current app language. If key is missing, fallback to legacy constants.
  const key = `categories:items.${category}`;
  const localized = i18n.t(key);
  if (typeof localized === 'string' && localized !== key) return localized;
  return CATEGORY_LABELS[category] ?? category;
}

export function formatAutoTitle(category: ItemCategory, number: number): string {
  return `${getLocalizedCategoryLabel(category)} ${number}`;
}

/**
 * Returns the next available counter for a category.
 *
 * Priority for determining used numbers:
 * 1) metadata.autoTitle (canonical, locale-independent)
 * 2) parsing existing titles against i18n/legacy labels (backward compatibility)
 */
export function getNextCategoryNumber(
  category: ItemCategory,
  existingItems: WardrobeItem[],
): number {
  const candidates = getCategoryLabelCandidates(category);
  let maxNumber = 0;

  for (const item of existingItems) {
    if (item.category !== category) continue;

    const auto = item.metadata?.autoTitle as AutoTitleMetadata | undefined;
    if (
      auto?.kind === 'categoryCounter' &&
      auto.category === category &&
      typeof auto.number === 'number'
    ) {
      maxNumber = Math.max(maxNumber, auto.number);
      continue;
    }

    const parsed = extractNumberFromTitle(item.title, candidates);
    if (parsed != null) maxNumber = Math.max(maxNumber, parsed);
  }

  return maxNumber + 1;
}

export function createAutoTitle(
  category: ItemCategory,
  existingItems: WardrobeItem[],
): { title: string; autoTitle: AutoTitleMetadata } {
  const number = getNextCategoryNumber(category, existingItems);
  return {
    title: formatAutoTitle(category, number),
    autoTitle: { kind: 'categoryCounter', category, number },
  };
}

export function generateItemTitle(category: ItemCategory, existingItems: WardrobeItem[]): string {
  return createAutoTitle(category, existingItems).title;
}

export function getOrGenerateItemTitle(
  userTitle: string | undefined,
  category: ItemCategory,
  existingItems: WardrobeItem[],
): string {
  if (userTitle && userTitle.trim().length > 0) {
    return userTitle.trim();
  }
  return generateItemTitle(category, existingItems);
}

/**
 * Legacy helper: best-effort detection by string pattern.
 * Prefer using `item.metadata.autoTitle` when available.
 */
export function isAutoGeneratedTitle(title: string | undefined, category?: ItemCategory): boolean {
  if (!title) return false;

  if (category) {
    return extractNumberFromTitle(title, getCategoryLabelCandidates(category)) !== null;
  }

  const cats = Object.keys(CATEGORY_LABELS_EN) as ItemCategory[];
  for (const cat of cats) {
    if (extractNumberFromTitle(title, getCategoryLabelCandidates(cat)) !== null) return true;
  }
  return false;
}
